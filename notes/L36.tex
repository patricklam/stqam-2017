\documentclass[11pt]{article}
\usepackage{url}
\usepackage{listings}
\usepackage{tikz}
\usepackage{fontspec}
\usepackage{enumitem}
\setmainfont{Latin Modern Roman}
\setmonofont{Cousine}[Scale=MatchLowercase]
\usetikzlibrary{arrows,automata,shapes}
\tikzstyle{block} = [rectangle, draw, fill=blue!20, 
    text width=5em, text centered, rounded corners, minimum height=2em]
\tikzstyle{bt} = [rectangle, draw, fill=blue!20, 
    text width=1em, text centered, rounded corners, minimum height=2em]

\newtheorem{defn}{Definition}
\newtheorem{crit}{Criterion}
\newcommand{\true}{\mbox{\sf true}}
\newcommand{\false}{\mbox{\sf false}}

\newcommand{\handout}[5]{
  \noindent
  \begin{center}
  \framebox{
    \vbox{
      \hbox to 5.78in { {\bf Software Testing, Quality Assurance and Maintenance } \hfill #2 }
      \vspace{4mm}
      \hbox to 5.78in { {\Large \hfill #5  \hfill} }
      \vspace{2mm}
      \hbox to 5.78in { {\em #3 \hfill #4} }
    }
  }
  \end{center}
  \vspace*{4mm}
}

\newcommand{\lecture}[4]{\handout{#1}{#2}{#3}{#4}{Lecture #1}}
\topmargin 0pt
\advance \topmargin by -\headheight
\advance \topmargin by -\headsep
\textheight 8.9in
\oddsidemargin 0pt
\evensidemargin \oddsidemargin
\marginparwidth 0.5in
\textwidth 6.5in

\parindent 0in
\parskip 1.5ex
%\renewcommand{\baselinestretch}{1.25}

\usepackage[listings]{tcolorbox}
\newtcbinputlisting{\codelisting}[3][]{
    extrude left by=1em,
    extrude right by=2em,
    listing file={#3},
    fonttitle=\bfseries,
    listing options={basicstyle=\ttfamily\footnotesize,numbers=left,language=Java,#1},
    listing only,
    hbox,
}
\lstset{ %
language=Java,
basicstyle=\ttfamily,commentstyle=\scriptsize\itshape,showstringspaces=false,breaklines=true,numbers=left}

\definecolor{gray}{rgb}{0.4,0.4,0.4}
\definecolor{darkblue}{rgb}{0.0,0.0,0.6}
\definecolor{cyan}{rgb}{0.0,0.6,0.6}

\lstdefinelanguage{XML}
{
  morestring=[b]",
  morestring=[s]{>}{<},
  morecomment=[s]{<?}{?>},
  stringstyle=\color{black},
  identifierstyle=\color{darkblue},
  keywordstyle=\color{cyan},
  morekeywords={xmlns,version,type}% list your attributes here
}


\begin{document}

\lecture{36 --- April 3, 2017}{Winter 2017}{Patrick Lam}{version 1}

\section*{One more dynamic tool: Randoop}
    Key Idea:
    ``Writing tests is a difficult and time-consuming activity, 
  and yet it is a crucial part of good software engineering. 
  Randoop automatically generates unit tests for Java classes.''

  Randoop generates random sequence of method calls, 
  looking for object contract violations.
  
  To use it, simply point it at a program \& let it run.

  Randoop discards bad method sequences 
(e.g. illegal argument exceptions). It remembers method sequences that create complex objects,
    and sequences that result in object contract violations.\

  \begin{center}
    \url{code.google.com/p/randoop/}
  \end{center}

  Here is an example generated by Randoop:
  {\scriptsize
\begin{lstlisting}[language=Java]
public static void test1() {
    LinkedList list = new LinkedList();
    Object o1 = new Object();
    list.addFirst(o1);

    TreeSet t1 = new TreeSet(list);
    Set s1 = Collections.synchronizedSet(t1);

    // violated in the Java standard library!
    Assert.assertTrue(s1.equals(s1));
  }
\end{lstlisting}
}

\section*{Course Summary}
Many of the topics in this course are fairly straightforward. I hope that seeing them
all in one place can help you make connections between the different topics.

\subsection*{Introduction}
We started by talking about \emph{faults}, \emph{errors}, and \emph{failures}.
We also discussed \emph{static} versus \emph{dynamic} approaches, something which recurred
throughout the course. 

\subsection*{Defining Test Suites}
Before defining test suites, I thought it was important for everyone to understand
\emph{exploratory testing}. We then moved on to \emph{statement} and \emph{branch}
coverage, which require you to understand \emph{control-flow graphs}. Alternatively,
you might have a \emph{Finite State Machine} and want to build test suites to cover
round-trips in your FSM.

Grammar-based approaches are also important, particularly \emph{fuzzing} for security-based
properties. (Don't forget to try out the american fuzzy lop tool). We can also generate
inputs from a grammar.

\emph{Mutation testing} is probably the most difficult concept in the course. Recall that
it's indirect: you're trying to make your test suite better by making sure that it can actually
detect defects in the code.

We also looked at research which empirically evaluated best-case coverage of well-tested code
(JUnit, can reach 93\%; 80\% is usual benchmark); which evaluated the usefulness of mutation
testing (it actually works); and which evaluated the usefulness of coverage (not very, as a
goal in itself).

\subsection*{Engineering Test Suites}
We then moved on to discuss how to engineer test suites as artifacts. There's a lot more
that I would have liked to talk about, like ensuring testability and test smells. But here's
what we did discuss.

First, we talked about why you need good tests---it enables you to fearlessly modify your code
without worrying about breaking it (``eat your vegetables!'') We then talked about some
\emph{test design principles}. Moving on to more concrete points, we saw how Selenium let you
write tests for webapps. \emph{Regression testing} is also a key use for test suites; they should
be fast and automated.

Tests themselves should be \emph{self-checking}. They might verify either \emph{state} or
\emph{behaviour} (using \emph{mock objects}). They should be hooked up to a \emph{continuous
integration} system and should not be \emph{flaky}.

\subsection*{Tools}
A fundamental distinction is between \emph{dynamic} and \emph{static} approaches. Dynamic approaches
have perfect information about a limited set of runs; static approaches have approximations which
are valid for all runs.

We talked about bug-finding tools somewhat out of sequence to enable
you to work on your project.  The fundamental idea behind Coverity is
to find contradictions and suspicious usage patterns. Your project
does the same, but at a simpler level.

On to real tools, the first technique I talked about was still not a tool:
\emph{code review}. Along the same lines, \emph{reporting bugs} is also important
to talk about, but not strictly speaking a tool either.

We finally continued with real tools: \emph{PMD} and \emph{FindBugs},
which statically detect suspicious code patterns in Java source code
and bytecode respectively. We also saw how to use PMD to run queries
on your own codebases (using XPath expressions). {\tt jshint} is another
tool in the same spirit, but it detects sketchiness in JavaScript
(like undefined variables, which you can't even use in sane languages).
\emph{Facebook Infer} uses more powerful static analysis to find memory
leaks and null pointer dereferences, among others. All of these tools
work on significant codebases.

Finally, on the dynamic tool side, we talked about \emph{valgrind}
and \emph{Address Sanitizer}, which detect memory errors at runtime
by instrumenting the code.

\section*{Questions}

5 to 10 minutes for questions.

\section*{Your Education}
[Especially targetted towards 4B students] Congratulations. You're a
couple of final exams away from graduating. This is a good time to sum
up what you've learned here at Waterloo.

Your education started with a solid math foundation, including both
calculus and discrete math. The engineers also learned physics and
circuits. There are some foundational topics which you will never
again use in your life. But all technically educated people should
have seen differentiation, integration, multi-variable calculus, and
differential equations.

The discrete math is more helpful, as it provides a necessary
foundation for learning about algorithms. Again, you probably won't
implement many algorithms yourself. But you know how they work and can
make informed choices.

You also know about how a computer works at the hardware level---more
so for SE/ECE students, less so for CS students, but still a decent
knowledge. It's not magic. Continuing to go up the abstraction chain,
you have learned about core Computer Science topics. You've learned
how operating systems and compilers work. And you may have seen topics
in your Technical Electives like AI (which builds on probability)
or graphics.

At the same time, through your 8 terms at Waterloo and co-op jobs, you've
learned about communication, about working in teams, and about managing
a heavy workload.

You can be proud of your technical and your non-technical education at
Waterloo. Your capabilities are second to none compared to graduates
of other schools around the world.

\section*{Looking Forward}
Here we are. You are soon going to receive a degree from a top Canadian institution
in a field which is unquestionably thriving. What next?

{\bf Always be learning.} It's easy to get comfortable, to not examine
one's situation, and to get stuck in a rut. My suggestion is a
data-driven approach. Think about where you are, where you want to be
(and whether it will actually make you---not others---happy), and how to get
there. Take the steps you need to make it so. Don't worry about what's
in the past. You can only change the future.

Good luck, and see some of you at convocation!


\end{document}
